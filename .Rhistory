"sigma"),
Estimates = c(estimates_i),
Convergence = c(rep(results$convergence,
length(c(beta_param_names,
gamma_param_names,
theta_param_names,
"sigma")))))
} else if(interaction_indicator == TRUE & outcome_distribution == "Normal"){
results = turboEM::turboem(par = c(c(beta_start), c(gamma_start),
c(theta_start), sigma_start),
fixptfn = EM_function_normalY_XM,
method = c(em_method),
obs_mediator = Mstar,
obs_outcome = outcome,
X = X, Z = Z, c_matrix = c_matrix,
sample_size = sample_size, n_cat = n_cat,
control.run = control_settings)
# Recode observed mediator from 1/2, make 1/0
Mstar01 = ifelse(Mstar == 1, 1, ifelse(Mstar == 2, 0, NA))
# Do label switching correction within the EM algorithm simulation
design_matrix = cbind(X, c_matrix)
gamma_index_1 = ncol(design_matrix) + 1
gamma_index_2 = gamma_index_1 + (ncol(Z) * 2) - 1
n_param <- length(turboEM::pars(results))
results_i_gamma <- matrix(turboEM::pars(results)[gamma_index_1:gamma_index_2],
ncol = n_cat, byrow = FALSE)
results_i_pistar_v <- pistar_compute(results_i_gamma, Z, sample_size, n_cat)
pistar_11 <- mean(results_i_pistar_v[1:sample_size, 1])
pistar_22 <- mean(results_i_pistar_v[(sample_size + 1):(2*sample_size), 2])
flip_pistar11 <- 1 - pistar_22
flip_pistar22 <- 1 - pistar_11
J <- pistar_11 + pistar_22 - 1
J_flip <- flip_pistar11 + flip_pistar22 - 1
estimates_i <- if ((J_flip <= J) |
(is.na(pistar_11) & is.na(pistar_22))) {
# If turboem cannot estimate the parameters they will be NA.
turboEM::pars(results)
} else {
gamma_index = gamma_index_1:gamma_index_2
n_gamma_param = length(gamma_index) / n_cat
gamma_flip_index = ncol(design_matrix) + c((n_gamma_param + 1):length(gamma_index), 1:n_gamma_param)
c(-1*turboEM::pars(results)[1:ncol(design_matrix)], # beta * -1
turboEM::pars(results)[gamma_flip_index], # flip gammas
turboEM::pars(results)[gamma_index_2 + 1] + turboEM::pars(results)[n_param - ncol(c_mat)], # add theta_m to intercept
turboEM::pars(results)[(gamma_index_2 + 2):(gamma_index_2 + 1 + ncol(x_mat))] + turboEM::pars(results)[n_param],
-1 * turboEM::pars(results)[gamma_index_2 + 1 + ncol(x_mat) + 1], # multiply theta_m by -1
turboEM::pars(results)[(gamma_index_2 + 1 + ncol(x_mat) + 1 + 1):(n_param - 1)],
-1 * turboEM::pars(results)[n_param])
}
# Set parameter names
beta_param_names <- paste0(rep("beta_", ncol(design_matrix)), 0:(ncol(design_matrix) - 1))
gamma_param_names <- paste0(rep("gamma", (n_cat * ncol(Z))),
rep(1:ncol(Z), n_cat),
rep(1:n_cat, each = ncol(Z)))
theta_param_names <- c("theta_0",
"theta_x",
"theta_m",
paste0(rep("theta_c", ncol(c_mat)), 1:ncol(c_mat)),
"theta_xm")
# Return data frame of estimates
estimates <- data.frame(Parameter = c(beta_param_names,
gamma_param_names,
theta_param_names,
"sigma"),
Estimates = c(estimates_i),
Convergence = c(rep(results$convergence,
length(c(beta_param_names,
gamma_param_names,
theta_param_names,
"sigma")))))
} else if(interaction_indicator == FALSE & outcome_distribution == "Poisson"){
results = turboEM::turboem(par = c(c(beta_start), c(gamma_start),
c(theta_start)),
fixptfn = EM_function_poissonY,
method = c(em_method),
obs_mediator = Mstar,
obs_outcome = outcome,
X = X, Z = Z, c_matrix = c_matrix,
sample_size = sample_size, n_cat = n_cat,
control.run = control_settings)
# Recode observed mediator from 1/2, make 1/0
Mstar01 = ifelse(Mstar == 1, 1, ifelse(Mstar == 2, 0, NA))
# Do label switching correction within the EM algorithm simulation
design_matrix = cbind(X, c_matrix)
gamma_index_1 = ncol(design_matrix) + 1
gamma_index_2 = gamma_index_1 + (ncol(Z) * 2) - 1
n_param <- length(turboEM::pars(results))
results_i_gamma <- matrix(turboEM::pars(results)[gamma_index_1:gamma_index_2],
ncol = n_cat, byrow = FALSE)
results_i_pistar_v <- pistar_compute(results_i_gamma, Z, sample_size, n_cat)
pistar_11 <- mean(results_i_pistar_v[1:sample_size, 1])
pistar_22 <- mean(results_i_pistar_v[(sample_size + 1):(2*sample_size), 2])
flip_pistar11 <- 1 - pistar_22
flip_pistar22 <- 1 - pistar_11
J <- pistar_11 + pistar_22 - 1
J_flip <- flip_pistar11 + flip_pistar22 - 1
estimates_i <- if ((J_flip <= J) |
(is.na(pistar_11) & is.na(pistar_22))) {
# If turboem cannot estimate the parameters they will be NA.
turboEM::pars(results)
} else {
gamma_index = gamma_index_1:gamma_index_2
n_gamma_param = length(gamma_index) / n_cat
gamma_flip_index = ncol(design_matrix) + c((n_gamma_param + 1):length(gamma_index), 1:n_gamma_param)
c(-1*turboEM::pars(results)[1:ncol(design_matrix)], # beta * -1
turboEM::pars(results)[gamma_flip_index], # flip gammas
turboEM::pars(results)[gamma_index_2 + 1] + turboEM::pars(results)[n_param - ncol(c_mat)], # add theta_m to intercept
turboEM::pars(results)[(gamma_index_2 + 2):(gamma_index_2 + 1 + ncol(x_mat))],
-1 * turboEM::pars(results)[gamma_index_2 + 1 + ncol(x_mat) + 1], # multiply theta_m by -1
turboEM::pars(results)[(gamma_index_2 + 1 + ncol(x_mat) + 1 + 1):n_param])
}
# Set parameter names
beta_param_names <- paste0(rep("beta_", ncol(design_matrix)), 0:(ncol(design_matrix) - 1))
gamma_param_names <- paste0(rep("gamma", (n_cat * ncol(Z))),
rep(1:ncol(Z), n_cat),
rep(1:n_cat, each = ncol(Z)))
theta_param_names <- c("theta_0",
paste0(rep("theta_x", ncol(x_mat)), 1:ncol(x_mat)),
"theta_m",
paste0(rep("theta_c", ncol(c_mat)), 1:ncol(c_mat)))
# Return data frame of estimates
estimates <- data.frame(Parameter = c(beta_param_names,
gamma_param_names,
theta_param_names),
Estimates = c(estimates_i),
Convergence = c(rep(results$convergence,
length(c(beta_param_names,
gamma_param_names,
theta_param_names)))))
} else if(interaction_indicator == TRUE & outcome_distribution == "Poisson"){
results = turboEM::turboem(par = c(c(beta_start), c(gamma_start),
c(theta_start)),
fixptfn = EM_function_poissonY_XM,
method = c(em_method),
obs_mediator = Mstar,
obs_outcome = outcome,
X = X, Z = Z, c_matrix = c_matrix,
sample_size = sample_size, n_cat = n_cat,
control.run = control_settings)
# Recode observed mediator from 1/2, make 1/0
Mstar01 = ifelse(Mstar == 1, 1, ifelse(Mstar == 2, 0, NA))
# Do label switching correction within the EM algorithm simulation
design_matrix = cbind(X, c_matrix)
gamma_index_1 = ncol(design_matrix) + 1
gamma_index_2 = gamma_index_1 + (ncol(Z) * 2) - 1
n_param <- length(turboEM::pars(results))
results_i_gamma <- matrix(turboEM::pars(results)[gamma_index_1:gamma_index_2],
ncol = n_cat, byrow = FALSE)
results_i_pistar_v <- pistar_compute(results_i_gamma, Z, sample_size, n_cat)
pistar_11 <- mean(results_i_pistar_v[1:sample_size, 1])
pistar_22 <- mean(results_i_pistar_v[(sample_size + 1):(2*sample_size), 2])
flip_pistar11 <- 1 - pistar_22
flip_pistar22 <- 1 - pistar_11
J <- pistar_11 + pistar_22 - 1
J_flip <- flip_pistar11 + flip_pistar22 - 1
estimates_i <- if ((J_flip <= J) |
(is.na(pistar_11) & is.na(pistar_22))) {
# If turboem cannot estimate the parameters they will be NA.
turboEM::pars(results)
} else {
gamma_index = gamma_index_1:gamma_index_2
n_gamma_param = length(gamma_index) / n_cat
gamma_flip_index = ncol(design_matrix) + c((n_gamma_param + 1):length(gamma_index), 1:n_gamma_param)
c(-1*turboEM::pars(results)[1:ncol(design_matrix)], # beta * -1
turboEM::pars(results)[gamma_flip_index], # flip gammas
turboEM::pars(results)[gamma_index_2 + 1] + turboEM::pars(results)[n_param - ncol(c_mat)], # add theta_m to intercept
turboEM::pars(results)[(gamma_index_2 + 2):(gamma_index_2 + 1 + ncol(x_mat))] + turboEM::pars(results)[n_param],
-1 * turboEM::pars(results)[gamma_index_2 + 1 + ncol(x_mat) + 1], # multiply theta_m by -1
turboEM::pars(results)[(gamma_index_2 + 1 + ncol(x_mat) + 1 + 1):(n_param - 1)],
-1 * turboEM::pars(results)[n_param])
}
# Set parameter names
beta_param_names <- paste0(rep("beta_", ncol(design_matrix)), 0:(ncol(design_matrix) - 1))
gamma_param_names <- paste0(rep("gamma", (n_cat * ncol(Z))),
rep(1:ncol(Z), n_cat),
rep(1:n_cat, each = ncol(Z)))
theta_param_names <- c("theta_0",
"theta_x",
"theta_m",
paste0(rep("theta_c", ncol(c_mat)), 1:ncol(c_mat)),
"theta_xm")
# Return data frame of estimates
estimates <- data.frame(Parameter = c(beta_param_names,
gamma_param_names,
theta_param_names),
Estimates = c(estimates_i),
Convergence = c(rep(results$convergence,
length(c(beta_param_names,
gamma_param_names,
theta_param_names)))))
} else {
"Undefined"
}
return(estimates)
}
n_cat = 2 # Number of categories in mediator
sample_size = length(Mstar) # Sample size
# Create design matrices
X = matrix(c(rep(1, sample_size), c(x_matrix)),
byrow = FALSE, nrow = sample_size)
Z = matrix(c(rep(1, sample_size), c(z_matrix)),
byrow = FALSE, nrow = sample_size)
x_mat <- as.matrix(x_matrix)
c_mat <- as.matrix(c_matrix)
# Create a matrix of observed mediator variables using dummy coding
obs_M_reps = matrix(rep(Mstar, n_cat), nrow = sample_size, byrow = FALSE)
category_matrix = matrix(rep(1:n_cat, each = sample_size), nrow = sample_size,
byrow = FALSE)
obs_M_matrix = 1 * (obs_M_reps == category_matrix)
tolerance = 0.003
max_em_iterations
# EM algorithm settings
control_settings = list(convtype = "parameter", tol = tolerance,
stoptype = "maxiter", maxiter = max_em_iterations)
results = turboEM::turboem(par = c(c(beta_start), c(gamma_start),
c(theta_start), sigma_start),
fixptfn = EM_function_normalY_XM,
method = c(em_method),
obs_mediator = Mstar,
obs_outcome = outcome,
X = X, Z = Z, c_matrix = c_matrix,
sample_size = sample_size, n_cat = n_cat,
control.run = control_settings)
sigma_start <- 1
results = turboEM::turboem(par = c(c(beta_start), c(gamma_start),
c(theta_start), sigma_start),
fixptfn = EM_function_normalY_XM,
method = c(em_method),
obs_mediator = Mstar,
obs_outcome = outcome,
X = X, Z = Z, c_matrix = c_matrix,
sample_size = sample_size, n_cat = n_cat,
control.run = control_settings)
results
#' @return \code{EM_function_bernoulliY} returns a numeric vector of updated parameter
#'   estimates from one iteration of the EM-algorithm.
#'
#' @include pi_compute.R
#' @include pistar_compute.R
#' @include w_m_binaryY.R
#' @include w_m_normalY.R
#'
#' @importFrom stats rnorm rgamma rmultinom coefficients binomial
#'
EM_function_normalY_XM <- function(param_current,
obs_mediator, obs_outcome,
X, Z, c_matrix,
sample_size, n_cat){
# Create design matrix for true mediator model
design_matrix = cbind(X, c_matrix)
# Set up parameter indices
gamma_index_1 = ncol(design_matrix) + 1
gamma_index_2 = gamma_index_1 + (ncol(Z) * 2) - 1
n_param <- length(param_current)
# Separate current parameters into beta, gamma, theta, sigma vectors
beta_current = matrix(param_current[1:ncol(design_matrix)], ncol = 1)
gamma_current = matrix(c(param_current[gamma_index_1:gamma_index_2]),
ncol = n_cat, byrow = FALSE)
theta_current = matrix(c(param_current[(gamma_index_2 + 1):(n_param - 1)]),
ncol = 1)
sigma_current = param_current[n_param]
# Compute probability of each latent mediator value
probabilities = pi_compute(beta_current, design_matrix, sample_size, n_cat)
# Compute probability of observed mediator, given latent mediator
conditional_probabilities = pistar_compute(gamma_current, Z, sample_size, n_cat)
# Compute likelihood value of Y based on x, m, c, theta, and sigma
interaction_term_m0 <- X[,-1] * 0
outcome_design_matrix_m0 <- cbind(cbind(X, cbind(rep(0, sample_size), c_matrix)),
interaction_term_m0)
model_y_m0 <- outcome_design_matrix_m0 %*% theta_current
residual_term_m0 = obs_outcome - model_y_m0
term1_m0 = 1 / sqrt(2 * pi * c(sigma_current ^ 2))
exp_term_m0 = exp(-1 * residual_term_m0^2 * (1 / c(2 * sigma_current^2)))
p_yi_m0 = term1_m0 * exp_term_m0
interaction_term_m1 <- X[,-1] * 1
outcome_design_matrix_m1 <- cbind(cbind(X, cbind(rep(1, sample_size), c_matrix)),
interaction_term_m1)
model_y_m1 <- outcome_design_matrix_m1 %*% theta_current
residual_term_m1 = obs_outcome - model_y_m1
term1_m1 = 1 / sqrt(2 * pi * c(sigma_current ^ 2))
exp_term_m1 = exp(-1 * residual_term_m1^2 * (1 / c(2 * sigma_current^2)))
p_yi_m1 = term1_m1 * exp_term_m1
# Create a matrix of observed mediator variables using dummy coding
mstar_matrix = matrix(c(ifelse(obs_mediator == 1, 1, 0),
ifelse(obs_mediator == 2, 1, 0)),
nrow = sample_size, byrow = FALSE)
# Compute E-Step weights
weights = w_m_normalY(mstar_matrix,
pistar_matrix = conditional_probabilities,
pi_matrix = probabilities,
p_yi_m0, p_yi_m1,
sample_size, n_cat)
# Estimate gamma parameters using weighted logistic regression
## Weights from E-Step (split by value of latent mediator, m)
## Outcome is the observed mediator
Mstar01 = mstar_matrix[,1]
fit.gamma1 <- suppressWarnings( stats::glm(Mstar01 ~ . + 0, as.data.frame(Z),
weights = weights[,1],
family = "binomial"(link = "logit")) )
gamma1_new <- unname(coefficients(fit.gamma1))
fit.gamma2 <- suppressWarnings( stats::glm(Mstar01 ~ . + 0, as.data.frame(Z),
weights = weights[,2],
family = "binomial"(link = "logit")) )
gamma2_new <- unname(coefficients(fit.gamma2))
# Estimate beta parameters using logistic regression
## Outcome is the E-Step weight
fit.beta <- suppressWarnings( stats::glm(weights[,1] ~ . + 0, as.data.frame(design_matrix),
family = stats::binomial()) )
beta_new <- unname(coefficients(fit.beta))
if(ncol(matrix(c_matrix, nrow = sample_size, byrow = FALSE)) == 1){
# Solve for theta parameters using a system of equations
a_row1 <- c(1, mean(X[,2]), mean(c_matrix), mean(weights[,1]))
a_row2 <- c(sum(X[,2]) / sum(X[,2]^2), 1, sum(X[,2] * c_matrix) / sum(X[,2]^2),
sum(X[,2] * weights[,1]) / sum(X[,2]^2))
a_row3 <- c(sum(c_matrix) / sum(c_matrix^2), sum(c_matrix * X[,2]) / sum(c_matrix^2),
1, sum(c_matrix * weights[,1]) / sum(c_matrix^2))
a_row4 <- c(1, sum(X[,2] * weights[,1]) / sum(weights[,1]),
sum(c_matrix * weights[,1]) / sum(weights[,1]), 1)
A = matrix(c(a_row1, a_row2, a_row3, a_row4), byrow = TRUE, nrow = 4)
B = matrix(c(mean(obs_outcome), sum(X[,2] * obs_outcome) / sum(X[,2]^2),
sum(c_matrix * obs_outcome) / sum(c_matrix^2),
sum(weights[,1] * obs_outcome) / sum(weights[,1])),
ncol = 1)
theta_update <- solve(A, B)
# Compute sigma estimate
sigma_update <- (1 / sample_size) * sum(
((obs_outcome - theta_update[1] - theta_update[2] * X[,2]
- theta_update[3] * c_matrix) ^ 2)
- 2 * theta_update[4] * weights[,1] * (obs_outcome - theta_update[1] - theta_update[2] * X[,2]
- theta_update[3] * c_matrix)
+ (theta_update[4] ^ 2 * weights[,1])
)
# Reorder theta estimates
theta_new <- theta_update[c(1,2,4,3)]
sigma_new <- sigma_update
} else {
theta_sigma_new_optim <- optim(par = c(theta_current, sigma_current),
fn = theta_optim_XM,
m = weights[,1],
x = X[,2], c = c_matrix,
outcome = obs_outcome,
sample_size = sample_size,
n_cat = 2, method = "BFGS")
theta_new <- theta_sigma_new_optim$par[-length(theta_sigma_new_optim$par)]
sigma_new <- theta_sigma_new_optim$par[length(theta_sigma_new_optim$par)]
}
# Save new parameters
param_new = c(beta_new, gamma1_new, gamma2_new, theta_new, sigma_new)
param_new
param_current = param_new
return(param_new)
}
#'   and the observed outcome, \code{M*}, can take.
#'
#' @return \code{w_m_normalY} returns a matrix of E-step weights for the EM-algorithm.
#'   Rows of the matrix correspond to each subject. Columns of the matrix correspond
#'   to the true mediator categories \eqn{j = 1, \dots,} \code{n_cat}.
#'
#' @include pi_compute.R
#' @include pistar_compute.R
#'
#' @importFrom stats rnorm rgamma rmultinom
w_m_normalY <- function(mstar_matrix, # Observed mediator matrix
pistar_matrix, # Probability of observed mediator given latent mediator
pi_matrix, # Mediator probabilities
p_yi_m0, p_yi_m1, # Likelihood value of Y for given M
sample_size, n_cat){
y_m1_mstar1_frac1 = p_yi_m1 * mstar_matrix[,1] * pistar_matrix[1:sample_size, 1] *
pi_matrix[,1]
y_m2_mstar1_frac1 = p_yi_m0 * mstar_matrix[,1] * pistar_matrix[1:sample_size, 2] *
pi_matrix[,2]
y_m1_mstar2_frac1 = p_yi_m1 * mstar_matrix[,2] *
pistar_matrix[(sample_size + 1):(n_cat * sample_size), 1] * pi_matrix[,1]
y_m2_mstar2_frac1 = p_yi_m0 * mstar_matrix[,2] *
pistar_matrix[(sample_size + 1):(n_cat * sample_size), 2] * pi_matrix[,2]
mstar1_frac2 = (p_yi_m1 * pistar_matrix[1:sample_size, 1] * pi_matrix[,1]) +
(p_yi_m0 * pistar_matrix[1:sample_size, 2] * pi_matrix[,2])
mstar2_frac2 = (p_yi_m0 *
pistar_matrix[(sample_size + 1):(n_cat * sample_size), 2]
* pi_matrix[,2]) +
(p_yi_m1 * pistar_matrix[(sample_size + 1):(n_cat * sample_size), 1] * pi_matrix[,1])
m1_term = (y_m1_mstar1_frac1 / mstar1_frac2) + (y_m1_mstar2_frac1 / mstar2_frac2)
m2_term = (y_m2_mstar1_frac1 / mstar1_frac2) + (y_m2_mstar2_frac1 / mstar2_frac2)
weight_m = matrix(c(m1_term, m2_term), nrow = sample_size, byrow = FALSE)
return(weight_m)
}
m = weights[,1]
x = X[,2]
c_matrix = c_matrix
outcome = obs_outcome
# Create design matrix for true mediator model
design_matrix = cbind(X, c_matrix)
# Set up parameter indices
gamma_index_1 = ncol(design_matrix) + 1
gamma_index_2 = gamma_index_1 + (ncol(Z) * 2) - 1
n_param <- length(param_current)
# Separate current parameters into beta, gamma, theta, sigma vectors
beta_current = matrix(param_current[1:ncol(design_matrix)], ncol = 1)
gamma_current = matrix(c(param_current[gamma_index_1:gamma_index_2]),
ncol = n_cat, byrow = FALSE)
theta_current = matrix(c(param_current[(gamma_index_2 + 1):(n_param - 1)]),
ncol = 1)
sigma_current = param_current[n_param]
# Compute probability of each latent mediator value
probabilities = pi_compute(beta_current, design_matrix, sample_size, n_cat)
# Compute probability of observed mediator, given latent mediator
conditional_probabilities = pistar_compute(gamma_current, Z, sample_size, n_cat)
# Compute likelihood value of Y based on x, m, c, theta, and sigma
interaction_term_m0 <- X[,-1] * 0
outcome_design_matrix_m0 <- cbind(cbind(X, cbind(rep(0, sample_size), c_matrix)),
interaction_term_m0)
model_y_m0 <- outcome_design_matrix_m0 %*% theta_current
residual_term_m0 = obs_outcome - model_y_m0
term1_m0 = 1 / sqrt(2 * pi * c(sigma_current ^ 2))
theta_current
outcome_design_matrix
# Create design matrix for true mediator model
design_matrix = cbind(X, c_matrix)
# Set up parameter indices
gamma_index_1 = ncol(design_matrix) + 1
gamma_index_2 = gamma_index_1 + (ncol(Z) * 2) - 1
n_param <- length(param_current)
# Separate current parameters into beta, gamma, theta, sigma vectors
beta_current = matrix(param_current[1:ncol(design_matrix)], ncol = 1)
param_current <- c(c(beta_start), c(gamma_start),
c(theta_start), sigma_start)
# Create design matrix for true mediator model
design_matrix = cbind(X, c_matrix)
# Set up parameter indices
gamma_index_1 = ncol(design_matrix) + 1
gamma_index_2 = gamma_index_1 + (ncol(Z) * 2) - 1
n_param <- length(param_current)
# Separate current parameters into beta, gamma, theta, sigma vectors
beta_current = matrix(param_current[1:ncol(design_matrix)], ncol = 1)
gamma_current = matrix(c(param_current[gamma_index_1:gamma_index_2]),
ncol = n_cat, byrow = FALSE)
theta_current = matrix(c(param_current[(gamma_index_2 + 1):(n_param - 1)]),
ncol = 1)
sigma_current = param_current[n_param]
# Compute probability of each latent mediator value
probabilities = pi_compute(beta_current, design_matrix, sample_size, n_cat)
# Compute probability of observed mediator, given latent mediator
conditional_probabilities = pistar_compute(gamma_current, Z, sample_size, n_cat)
# Compute likelihood value of Y based on x, m, c, theta, and sigma
interaction_term_m0 <- X[,-1] * 0
outcome_design_matrix_m0 <- cbind(cbind(X, cbind(rep(0, sample_size), c_matrix)),
interaction_term_m0)
model_y_m0 <- outcome_design_matrix_m0 %*% theta_current
residual_term_m0 = obs_outcome - model_y_m0
dim(outcome_design_matrix_m0)
dim(theta_new)
dim(theta_current)
gamma_index_1
gamma_index_2
param_current
length(param_current)
ncol(design_matrix)
# Create design matrix for true mediator model
design_matrix = cbind(X, c_matrix[,-1])
devtools::document()
devtools::document()
library(COMMA)
detach("package:COMMA", unload = TRUE)
devtools::install_github("kimberlywebb/COMMA")
knitr::opts_chunk$set(echo = TRUE,
warning = FALSE, error = FALSE, message = FALSE,
fig.align = "center")
library(ggplot2)
library(kableExtra)
library(devtools)
#install_github("kimberlywebb/COMMA")
library(COMMA)
library(dplyr)
set.seed(20240422)
sample_size <- 10000
n_cat <- 2 # Number of categories in the binary mediator
# Data generation settings
x_mu <- 0
x_sigma <- 1
z_shape <- 1
z_scale <- 1
c_shape <- 1
# True parameter values (gamma terms set the misclassification rate)
true_beta <- matrix(c(1, -2, .5), ncol = 1)
true_gamma <- matrix(c(1.8, 1, -1.5, -1), nrow = 2, byrow = FALSE)
true_theta <- matrix(c(1, 1.5, -2.5, -.2), ncol = 1)
c1 <- rnorm(sample_size)
true_theta <- matrix(c(1, 1.5, -2.5, -.2, .5, -.7), ncol = 1)
# True parameter values (gamma terms set the misclassification rate)
true_beta <- matrix(c(1, -2, .5, -.3), ncol = 1)
n_cat <- 2 # Number of categories in mediator
# Generate X
x <- rnorm(sample_size, x_mu, x_sigma)
x_matrix <- matrix(c(rep(1, sample_size),
x),
nrow = sample_size, byrow = FALSE)
# Generate Z
z <- rgamma(sample_size, z_shape)
z_matrix <- matrix(c(rep(1, sample_size),
z),
nrow = sample_size, byrow = FALSE)
# Generate C
c <- rgamma(sample_size, c_shape)
c_matrix <- matrix(c(rep(1, sample_size),
c, c1),
nrow = sample_size, byrow = FALSE)
# Create matrix of predictors for the true mediator
predictor_matrix <- cbind(x_matrix, c_matrix[,-1])
# Generate probabilities for the true mediator value
pi_matrix <- pi_compute(true_beta, predictor_matrix, sample_size, n_cat)
# Generate probabilities for the true mediator value
pi_matrix <- COMMA:::pi_compute(true_beta, predictor_matrix, sample_size, n_cat)
