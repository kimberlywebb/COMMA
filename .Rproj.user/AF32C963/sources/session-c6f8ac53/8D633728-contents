# Simulation code:
## - Poisson outcome (Y)
## - Low misclassification rate (2% - 5%)

################################################################################
# Load functions

#### UPDATE THIS FOR YOUR OWN COMPUTER! ####
function_directory <- "C:/Users/kimho/Dropbox/Misclassification/Code/Mediation/simulation_studies/functions/"
source_files <- list.files(function_directory, pattern = "*.R")
for (i in 1:length(source_files)) {
  source(paste0(function_directory, source_files[i]))
}

################################################################################
# Set save directory
save_directory <- "C:/Users/kimho/Dropbox/Misclassification/Code/Mediation/simulation_studies/results/"

################################################################################
# Load required packages
library(dplyr)
library(stringr)
library(splines)

################################################################################
# Simulation settings

sample_size <- 10000

n_cat <- 2 # Number of categories in the binary mediator

# Data generation settings
x_mu <- 0
x_sigma <- 1
z_shape <- 1
z_scale <- 1
c_shape <- 1

# True parameter values (gamma terms set the misclassification rate)
#true_beta <- matrix(c(1, -2, .5), ncol = 1)
#true_gamma <- matrix(c(3, 2, -2, -2.5), nrow = 2, byrow = FALSE)
#true_theta <- matrix(c(1, 1.5, -2, -.2), ncol = 1)

true_beta <- matrix(c(1, -2, .5), ncol = 1)
true_gamma <- matrix(c(3, 2, -2, -2.5), nrow = 2, byrow = FALSE)
true_theta <- matrix(c(-3, 1, -1, -.2, .5), ncol = 1)

################################################################################
# Run simulations

set.seed(123)

#### UPDATE THIS! ####
n_sim <- 500

# Set up prallelization
require(doParallel)

cluster <- makeCluster(10) 
registerDoParallel(cluster)

s25_sim_results <- foreach(i = 1:n_sim, .combine = "rbind",
                           .packages = c("splines")) %dopar% {
  
  # Generate data
  data <- mediation_data_poissonY_XM(sample_size, x_mu, x_sigma, z_shape, c_shape,
                                  true_beta, true_gamma, true_theta)
  
  prop.table(table(data$true_mediator))
  prop.table(table(data$obs_mediator))
  prop.table(table(data$obs_mediator, data$true_mediator), 2)
  
  # EM #########################################################################
  # Set starting values for the EM algorithm
  start_beta <- matrix(rep(1, 3), ncol = 1)
  start_gamma <- matrix(rep(1, 4), nrow = 2, ncol = 2)
  start_theta <- matrix(rep(1, 5), ncol = 1)
  
  # Run the EM algorithm
  EM_results <- mediation_EM_poissonY_XM(Mstar = data[["obs_mediator"]],
                                      outcome = data[["outcome"]],
                                      x_matrix = data[["x"]],
                                      z_matrix = data[["z"]],
                                      c_matrix = data[["c"]],
                                      beta_start = start_beta,
                                      gamma_start = start_gamma,
                                      theta_start = start_theta,
                                      tolerance = 1e-7,
                                      max_em_iterations = 1500,
                                      em_method = "squarem")
  
  # Update simulation indicator vector
  EM_results$Sim <- i
  EM_results$Method <- "EM"
  
  # PVW ########################################################################
  # Create matrix of true mediation model predictors
  mediation_model_predictors <- matrix(c(data[["x"]], data[["c"]]), ncol = 2,
                                       byrow = FALSE)
  Sys.time()
  # Run the COMBO EM algorithm for the true and observed mediation model
  COMBO_EM_results <- COMBO_EM_algorithm(data[["obs_mediator"]],
                                         mediation_model_predictors,
                                         data[["z"]],
                                         start_beta, start_gamma)
  # Save results
  predicted_beta <- matrix(COMBO_EM_results$Estimates[1:3], ncol = 1)
  predicted_gamma <- matrix(COMBO_EM_results$Estimates[4:7], 
                            ncol = 2, byrow = FALSE)
  
  # Create a matrix of observed mediator variables using dummy coding
  mstar_matrix <- matrix(c(ifelse(data[["obs_mediator"]] == 1, 1, 0),
                           ifelse(data[["obs_mediator"]] == 2, 1, 0)),
                         ncol = 2, byrow = FALSE)
  
  # Create matrix of predictors for the true mediator
  X_design <- matrix(c(rep(1, sample_size), data[["x"]], data[["c"]]),
                     ncol = 3, byrow = FALSE)
  
  # Generate probabilities for the true mediator value based on EM results
  pi_matrix <- pi_compute(predicted_beta, X_design, sample_size, n_cat)
  
  # Create matrix of predictors for the observed mediator
  Z_design <- matrix(c(rep(1, sample_size), data[["z"]]),
                     ncol = 2, byrow = FALSE)
  
  # Generate probabilities for observed mediator conditional on true mediator
  ## Based on EM results
  pistar_matrix <- pistar_compute(predicted_gamma, Z_design, sample_size, n_cat)
  
  # Estimate sensitivity and specificity
  sensitivity <- pistar_matrix[1:sample_size, 1]
  specificity <- pistar_matrix[(sample_size + 1):(2 * sample_size), 2]
  
  # Organize data for model predicting the observed mediator
  mstar_model_data <- data.frame(x = data[["x"]], c = data[["c"]], z = data[["z"]],
                                 y = data[["outcome"]],
                                 mstar = data[["obs_mediator"]])
  
  # Code observed mediator as 0/1 not 2/1
  mstar_model_data$mstar_01 <- ifelse(mstar_model_data$mstar == 1, 1, 0)
  
  # Fit spline model for observed mediator based on x, c, y, z
  mstar_model <- glm(mstar_01 ~ x*y*z*c,
                     data = mstar_model_data, family = "binomial")
  
  # Predict observed mediators
  predictions <- predict(mstar_model, type = "response")
  
  # Ensure no exact 0 or 1 values
  sensitivity[predictions >= sensitivity] <- predictions[predictions >= sensitivity] + 0.001
  specificity[predictions <= (1-specificity)] <- 1 - predictions[predictions <= (1 - specificity)] + 0.001
  
  # Compute NPV and PPV
  term1 <- (sensitivity - 1) * predictions * (1 / (sensitivity * (predictions - 1)))
  term2 <- (specificity - 1) * (predictions - 1) * (1 / (specificity * predictions))
  det <- 1/(term1*term2-1)
  ppv_calc <- det * (term2 - 1)
  npv_calc <- det * (term1 - 1)
  
  ppv <- unname(ppv_calc)
  npv <- unname(npv_calc)
  
  # Duplicate the dataset
  actual_dataset <- data.frame(x = data[["x"]], c = data[["c"]], z = data[["z"]],
                               y = data[["outcome"]], m = 0,
                               mstar_01 = mstar_model_data$mstar_01)
  
  duplicate_dataset <- data.frame(x = data[["x"]], c = data[["c"]], z = data[["z"]],
                                  y = data[["outcome"]], m = 1,
                                  mstar_01 = mstar_model_data$mstar_01)
  
  doubled_data <- rbind(actual_dataset, duplicate_dataset)
  doubled_data$y_01 <- ifelse(doubled_data$y == 1, 1, 0)
  
  # Apply NPV and PPV weights
  doubled_data$w <- 0
  doubled_data$w[doubled_data$m == 1 & doubled_data$mstar_01 == 1] <- ppv[which(doubled_data$m == 1 & doubled_data$mstar_01 == 1) - sample_size]
  doubled_data$w[doubled_data$m == 0 & doubled_data$mstar_01 == 1] <- 1 - ppv[doubled_data$m == 0 & doubled_data$mstar_01 == 1]
  doubled_data$w[doubled_data$m == 1 & doubled_data$mstar_01 == 0] <- 1 - npv[which(doubled_data$m == 1 & doubled_data$mstar_01 == 0) - sample_size]
  doubled_data$w[doubled_data$m == 0 & doubled_data$mstar_01 == 0] <- npv[doubled_data$m == 0 & doubled_data$mstar_01 == 0]
  
  hist(doubled_data$w)
  
  # Remove negative weights (why are these happening?)
  doubled_data$w_no_negative <- ifelse(doubled_data$w < 0, 0, doubled_data$w)
  
  # Fit weighted logistic regression to estimate theta
  weighted_outcome_model <- glm(y ~ x + c + m + x*m, weights = w_no_negative,
                                family = "poisson"(link = "log"),
                                data = doubled_data)
  summary(weighted_outcome_model)
  Sys.time()
  
  
  #  Save results and reorder theta
  PVW_results <- data.frame(Parameter = EM_results$Parameter,
                            Estimates = c(c(predicted_beta),
                                          c(predicted_gamma),
                                          c(unname(coefficients(weighted_outcome_model)))[c(1, 2, 4, 3, 5)]),
                            Convergence = rep(COMBO_EM_results$Convergence[1],
                                              12),
                            Sim = i,
                            Method = "PVW")
  
  # Naive ######################################################################
  mediation_example <- data.frame(x = data[["x"]], 
                                  m_01 = ifelse(data[["obs_mediator"]] == 1, 1, 0),
                                  c = data[["c"]],
                                  y = data[["outcome"]])
  
  out.model = glm(y ~ x + c + m_01 + x*m_01,
                  family = "poisson"(link = "log"),
                  data = mediation_example)
  med.model = glm(m_01 ~ x + c,
                  family = "binomial",
                  data = mediation_example)
  
  naive_results <- data.frame(Parameter = EM_results$Parameter[c(1:3, 8, 9, 11, 10, 12)],
                              Estimates = c(unname(coef(med.model)),
                                            unname(coef(out.model))),
                              Convergence = NA,
                              Sim = i,
                              Method = "Naive")
  
  all_results <- rbind(EM_results, PVW_results, naive_results)
  
  all_results$True_Values = c(true_beta, c(true_gamma), true_theta,
                              true_beta, c(true_gamma), true_theta,
                              true_beta, true_theta[c(1, 2, 4, 3, 5)])
  
  return(all_results)
}

stopCluster(cluster)

s25_sim_results %>%
  group_by(Parameter, True_Values) %>%
  summarise(mean_estimate = mean(Estimates),
            sd_estimate = sd(Estimates)) %>%
  ungroup()

save(s25_sim_results,
     file = paste0(save_directory,
                   "s25_PoissonY_LowMisclassification_XM_results.RData"))
