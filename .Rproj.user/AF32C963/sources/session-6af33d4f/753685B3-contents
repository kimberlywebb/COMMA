# Simulation code:
## - Binary outcome (Y)
## - Low misclassification rate (2% - 5%)

################################################################################
# Load functions

#### UPDATE THIS FOR YOUR OWN COMPUTER! ####
function_directory <- "C:/Users/kimho/Dropbox/Misclassification/Code/Mediation/simulation_studies/functions/"
source_files <- list.files(function_directory, pattern = "*.R")
for (i in 1:length(source_files)) {
  source(paste0(function_directory, source_files[i]))
}

################################################################################
# Set save directory
save_directory <- "C:/Users/kimho/Dropbox/Misclassification/Code/Mediation/simulation_studies/results/"

################################################################################
# Load required packages
library(dplyr)
library(stringr)
library(splines)

################################################################################
# Simulation settings

sample_size <- 10000

n_cat <- 2 # Number of categories in the binary mediator

# Data generation settings
x_mu <- 0
x_sigma <- 1
z_shape <- 1
z_scale <- 1
c_shape <- 1

# True parameter values (gamma terms set the misclassification rate)
true_beta <- matrix(c(1, -2, .5), ncol = 1)
true_gamma <- matrix(c(3, 2, -2, -2.5), nrow = 2, byrow = FALSE)
true_theta <- matrix(c(1, 1.5, -2, -.2), ncol = 1)
true_sigma <- 1

################################################################################
# Run simulations

set.seed(123)

#### UPDATE THIS! ####
n_sim <- 500 

# Set up prallelization
require(doParallel)

cluster <- makeCluster(10) 
registerDoParallel(cluster)

s4_sim_results <- foreach(i = 1:n_sim, .combine = "rbind",
                          .packages = c("splines")) %dopar% {
  
  # Generate data
  data <- mediation_data_normalY(sample_size,
                                 x_mu, x_sigma, z_shape, z_scale, c_shape,
                                 true_beta, true_gamma, true_theta)
  
  prop.table(table(data$true_mediator))
  prop.table(table(data$obs_mediator))
  prop.table(table(data$obs_mediator, data$true_mediator), 2)
  
  # EM #########################################################################
  # Set starting values for the EM algorithm
  start_beta <- matrix(rep(1, 3), ncol = 1)
  start_gamma <- matrix(rep(1, 4), nrow = 2, ncol = 2)
  start_theta <- matrix(rep(1, 4), ncol = 1)
  start_sigma <- 1
  
  # Run the EM algorithm
  EM_results <- mediation_EM_normalY(Mstar = data[["obs_mediator"]],
                                     outcome = data[["outcome"]],
                                     x_matrix = data[["x"]],
                                     z_matrix = data[["z"]],
                                     c_matrix = data[["c"]],
                                     beta_start = start_beta,
                                     gamma_start = start_gamma,
                                     theta_start = start_theta,
                                     sigma_start = start_sigma,
                                     tolerance = 1e-7,
                                     max_em_iterations = 1500,
                                     em_method = "squarem")
  
  # Update simulation indicator vector
  EM_results$Sim <- i
  EM_results$Method <- "EM"
  
  # PVW ########################################################################
  # Create matrix of true mediation model predictors
  mediation_model_predictors <- matrix(c(data[["x"]], data[["c"]]), ncol = 2,
                                       byrow = FALSE)
  
  # Run the COMBO EM algorithm for the true and observed mediation model
  COMBO_EM_results <- COMBO_EM_algorithm(data[["obs_mediator"]],
                                         mediation_model_predictors,
                                         data[["z"]],
                                         start_beta, start_gamma)
  # Save results
  predicted_beta <- matrix(COMBO_EM_results$Estimates[1:3], ncol = 1)
  predicted_gamma <- matrix(COMBO_EM_results$Estimates[4:7], 
                            ncol = 2, byrow = FALSE)
  
  # Create a matrix of observed mediator variables using dummy coding
  mstar_matrix <- matrix(c(ifelse(data[["obs_mediator"]] == 1, 1, 0),
                           ifelse(data[["obs_mediator"]] == 2, 1, 0)),
                         ncol = 2, byrow = FALSE)
  
  # Create matrix of predictors for the true mediator
  X_design <- matrix(c(rep(1, sample_size), data[["x"]], data[["c"]]),
                     ncol = 3, byrow = FALSE)
  
  # Generate probabilities for the true mediator value based on EM results
  pi_matrix <- pi_compute(predicted_beta, X_design, sample_size, n_cat)
  
  # Create matrix of predictors for the observed mediator
  Z_design <- matrix(c(rep(1, sample_size), data[["z"]]),
                     ncol = 2, byrow = FALSE)
  
  # Generate probabilities for observed mediator conditional on true mediator
  ## Based on EM results
  pistar_matrix <- pistar_compute(predicted_gamma, Z_design, sample_size, n_cat)
  
  # Estimate sensitivity and specificity
  sensitivity <- pistar_matrix[1:sample_size, 1]
  specificity <- pistar_matrix[(sample_size + 1):(2 * sample_size), 2]
  
  # Organize data for model predicting the observed mediator
  mstar_model_data <- data.frame(x = data[["x"]], c = data[["c"]], z = data[["z"]],
                                 y = data[["outcome"]],
                                 mstar = data[["obs_mediator"]])
  
  # Code observed mediator as 0/1 not 2/1
  mstar_model_data$mstar_01 <- ifelse(mstar_model_data$mstar == 1, 1, 0)
  
  # Fit spline model for observed mediator based on x, c, y, z
  mstar_model <- glm(mstar_01 ~ ns(y, 4) + ns(x, 4) + ns(c, 4) +
                       ns(x*c, 4) + ns(y*c, 4) + ns(z, 4),
                     data = mstar_model_data, family = "binomial")
  
  # Predict observed mediators
  predictions <- predict(mstar_model, type = "response")
  
  # Ensure no exact 0 or 1 values
  sensitivity[predictions >= sensitivity] <- predictions[predictions >= sensitivity] + 0.001
  specificity[predictions <= (1-specificity)] <- 1 - predictions[predictions <= (1 - specificity)] + 0.001
  
  # Compute NPV and PPV
  term1 <- (sensitivity - 1) * predictions * (1 / (sensitivity * (predictions - 1)))
  term2 <- (specificity - 1) * (predictions - 1) * (1 / (specificity * predictions))
  det <- 1/(term1*term2-1)
  ppv_calc <- det * (term2 - 1)
  npv_calc <- det * (term1 - 1)
  
  ppv <- unname(ppv_calc)
  npv <- unname(npv_calc)
  
  # Duplicate the dataset
  actual_dataset <- data.frame(x = data[["x"]], c = data[["c"]], z = data[["z"]],
                               y = data[["outcome"]], m = 0,
                               mstar_01 = mstar_model_data$mstar_01)
  
  duplicate_dataset <- data.frame(x = data[["x"]], c = data[["c"]], z = data[["z"]],
                                  y = data[["outcome"]], m = 1,
                                  mstar_01 = mstar_model_data$mstar_01)
  
  doubled_data <- rbind(actual_dataset, duplicate_dataset)
  doubled_data$y_01 <- ifelse(doubled_data$y == 1, 1, 0)
  
  # Apply NPV and PPV weights
  doubled_data$w <- 0
  doubled_data$w[doubled_data$m == 1 & doubled_data$mstar_01 == 1] <- ppv[which(doubled_data$m == 1 & doubled_data$mstar_01 == 1) - sample_size]
  doubled_data$w[doubled_data$m == 0 & doubled_data$mstar_01 == 1] <- 1 - ppv[doubled_data$m == 0 & doubled_data$mstar_01 == 1]
  doubled_data$w[doubled_data$m == 1 & doubled_data$mstar_01 == 0] <- 1 - npv[which(doubled_data$m == 1 & doubled_data$mstar_01 == 0) - sample_size]
  doubled_data$w[doubled_data$m == 0 & doubled_data$mstar_01 == 0] <- npv[doubled_data$m == 0 & doubled_data$mstar_01 == 0]
  
  # Fit weighted regression to estimate theta
  weighted_outcome_model <- lm(y ~ x + c + m, weights = w,
                               data = doubled_data)
  summary(weighted_outcome_model)
  
  #  Save results and reorder theta
  PVW_results <- data.frame(Parameter = EM_results$Parameter[1:11],
                            Estimates = c(c(predicted_beta),
                                          c(predicted_gamma),
                                          c(unname(coefficients(weighted_outcome_model)))[c(1, 2, 4, 3)]),
                            Convergence = rep(COMBO_EM_results$Convergence[1],
                                              11),
                            Sim = i,
                            Method = "PVW")
  
  # OLS ########################################################################
  # Compute the observed mediator prevalence
  prevalence <- length(which(data[["obs_mediator"]] == 1)) / sample_size
  
  # Compute average misclassification rates
  pistar12 <- pistar_matrix[1:sample_size, 2]
  pistar21 <- pistar_matrix[(sample_size + 1):(2 * sample_size), 1]
  
  # Compute correction parameters from Nguimkeu, Rosenman, and Tennekoon (2021)
  theta_Nguimkeu <- (pistar12 + pistar21) / (1 - pistar12 - pistar21)
  squiggle_Nguimkeu <- 1 - (((prevalence - pistar12)*(1 - pistar21 - prevalence)) / 
                              ((1 - pistar12 - pistar21)*(1 - prevalence)*prevalence))
  
  # Compute covariances for the correction
  m_matrix <- matrix(ifelse(data[["obs_mediator"]] == 1, 1, 0), ncol = 1)
  sd_dd <- cov(m_matrix)
  
  predictor_matrix <- matrix(c(data[["x"]], data[["c"]]), ncol = 2, byrow = FALSE)
  sd_xx <- cov(predictor_matrix)
  
  sd_xd <- cov(predictor_matrix, m_matrix)
  sd_dx <- cov(m_matrix, predictor_matrix)
  
  y_matrix <- matrix(data[["outcome"]], ncol = 1)
  sd_yd <- cov(y_matrix, m_matrix)
  sd_yx <- cov(y_matrix, predictor_matrix)
  
  block1_dd <- (1 - median(squiggle_Nguimkeu)) * sd_dd[1,1]
  block1_xd <- (1 + median(theta_Nguimkeu)) * sd_xd
  block_1_matrix <- matrix(c(block1_dd, block1_xd[,1],
                             sd_dx[,1], sd_xx[,1],
                             sd_dx[,2], sd_xx[,2]), byrow = FALSE,
                           nrow = 3)
  
  block_2_matrix <- matrix(c(sd_yd, sd_yx[1,]), ncol = 1)
  
  # Solve for the corrected parameters
  solve_param <- solve(block_1_matrix) %*% block_2_matrix
  solve_param
  
  # Compute the intercept
  intercept <- mean(data[["outcome"]]) -
    ((solve_param[1,1]) * (mean(m_matrix[,1]) - median(pistar12)) / (1 - median(pistar12) - median(pistar21))) -
    t(colMeans(predictor_matrix) %*% solve_param[-1,])
  
  # Intercept not estimated in "solve_param".
  OLS_results <- data.frame(Parameter = EM_results$Parameter[1:11], 
                            Estimates = c(c(predicted_beta), c(predicted_gamma),
                                          intercept, solve_param[c(2, 1, 3), 1]),
                            Convergence = rep(COMBO_EM_results$Convergence[1],
                                              11),
                            Sim = i,
                            Method = "OLS")
  
  # Naive ######################################################################
  mediation_example <- data.frame(x = data[["x"]], 
                                  m_01 = ifelse(data[["obs_mediator"]] == 1, 1, 0),
                                  c = data[["c"]],
                                  y = data[["outcome"]])
  
  out.model = lm(y ~ x + c + m_01,
                 data = mediation_example)
  med.model = glm(m_01 ~ x + c,
                  family = "binomial",
                  data = mediation_example)
  
  naive_results <- data.frame(Parameter = EM_results$Parameter[c(1:3, 8, 9, 11, 10)],
                              Estimates = c(unname(coef(med.model)),
                                            unname(coef(out.model))),
                              Convergence = NA,
                              Sim = i,
                              Method = "Naive")
  
  all_results <- rbind(EM_results, PVW_results, OLS_results, naive_results)
  
  all_results$True_Values = c(true_beta, c(true_gamma), true_theta, true_sigma,
                              true_beta, c(true_gamma), true_theta,
                              true_beta, c(true_gamma), true_theta,
                              true_beta, true_theta[c(1, 2, 4, 3)])
  
  return(all_results)
}

stopCluster(cluster)

save(s4_sim_results,
     file = paste0(save_directory,
                   "s4_NormalY_LowMisclassification_results.RData"))
